<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<NDepend IsCProject="false" AppName="New Project" Platform="DotNet">
  <OutputDir KeepHistoric="True" KeepXmlFiles="True">C:\projects\caesaria\source\CppDependOut</OutputDir>
  <Projects />
  <FrameworkProjects />
  <Dirs />
  <Report Kind="0" SectionsEnabled="45055" XslPath="" Flags="64512" />
  <BuildComparisonSetting ProjectMode="DontCompare" BuildMode="MostRecentAnalysisResultAvailable" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="1" FocusOnRecentRulesViolations="False" />
  <BaselineInUISetting ProjectMode="DontCompare" BuildMode="MostRecentAnalysisResultAvailable" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="1" FocusOnRecentRulesViolations="False" />
  <CoverageFiles UncoverableAttribute="" />
  <Plugins Plugin="true" Modernize="false" />
  <TrendMetrics UseCustomLog="False" LogRecurrence="1" LogLabel="2" UseCustomDir="False" CustomDir="">
    <Chart Name="Lines of Code" ShowInReport="True">
      <Serie MetricName="# Lines of Code" MetricUnit="Loc" Color="#FF00BFFF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Lines of Code (NotMyCode)" MetricUnit="Loc" Color="#FFA9A9A9" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Lines of Comments" MetricUnit="Lines" Color="#FF008000" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violated" ShowInReport="True">
      <Serie MetricName="# Rules" MetricUnit="Rules" Color="#FF66CDAA" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Rules Violated" MetricUnit="Rules" Color="#FFFF8C00" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Critical Rules Violated" MetricUnit="Rules" Color="#FFFF0000" ChartType="Area" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violations" ShowInReport="True">
      <Serie MetricName="# Rules Violations" MetricUnit="Violations" Color="#FFFF8C00" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Critical Rules Violations" MetricUnit="Violations" Color="#FFFF0000" ChartType="Area" ScaleExp="0" />
    </Chart>
    <Chart Name="Max" ShowInReport="True">
      <Serie MetricName="Max Cyclomatic Complexity for Methods" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max Cyclomatic Complexity for Types" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max # Lines of Code for Methods (JustMyCode)" MetricUnit="LoC" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max # of Methods for Types" MetricUnit="Methods" Color="#FF32CD32" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max Nesting Depth for Methods" MetricUnit="Scopes" Color="#FFFFD700" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Average" ShowInReport="True">
      <Serie MetricName="Average Cyclomatic Complexity for Methods" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average Cyclomatic Complexity for Types" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average # Lines of Code for Methods" MetricUnit="LoC" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average # Methods for Types" MetricUnit="Methods" Color="#FF32CD32" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average Nesting Depth for Methods" MetricUnit="Scopes" Color="#FFFFD700" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Third-Party Usage" ShowInReport="True">
      <Serie MetricName="# Third-Party Types Used" MetricUnit="Types" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Third-Party Methods Used" MetricUnit="Methods" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Third-Party Projects Used" MetricUnit="Projects" Color="#FF646464" ChartType="Line" ScaleExp="1" />
      <Serie MetricName="# Third-Party Namespaces Used" MetricUnit="Namespaces" Color="#FF32CD32" ChartType="Line" ScaleExp="1" />
      <Serie MetricName="# Third-Party Fields Used" MetricUnit="Fields" Color="#FFFFD700" ChartType="Line" ScaleExp="1" />
    </Chart>
  </TrendMetrics>
  <SourceFileRebasing FromPath="" ToPath="" /><Queries>
    <Group Name="Code Quality" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Types too big - critical</Name>
warnif count > 0 from t in JustMyCode.Types where 
   t.NbLinesOfCode > 500 && !t.IsGlobal
   orderby t.NbLinesOfCode descending
select new { t, t.NbLinesOfCode,
                t.NbMethods, t.NbFields }

// Types where NbLinesOfCode > 500 are extremely complex 
// and should be split in a smaller group of types. 
// See the definition of the NbLinesOfCode metric here 
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Methods too complex - critical</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.CyclomaticComplexity > 20 && 
  m.NestingDepth > 5
  orderby m.CyclomaticComplexity descending,
          m.NestingDepth descending
select new { m, m.CyclomaticComplexity, m.NestingDepth }

// Methods with CyclomaticComplexity > 20 and NestingDepth  > 5
// are really too complex and should be split 
// in smaller methods, or even types.
// See the definition of the CyclomaticComplexity metric here 
// http://www.cppdepend.com/Metrics.aspx#CC
// See the definition of the NestingDepth metric here 
// http://www.cppdepend.com/Metrics.aspx#NestingDepth]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Methods with too many parameters - critical</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbParameters > 8
  orderby m.NbParameters descending
select new { m, m.NbParameters }

// Methods with more than 8 parameters might be painful to call 
// and might degrade performance. You should prefer using 
// additional properties/fields to the declaring type to 
// handle numerous states. Another alternative is to provide 
// a class or structure dedicated to handle arguments passing 
//  See the definition of the NbParameters metric here 
// http://www.cppdepend.com/Metrics.aspx#NbParameters
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Quick summary of methods to refactor</Name>
warnif count > 0 from m in JustMyCode.Methods where 
                                    // Code Metrics' definitions
  m.NbLinesOfCode > 30 ||           // http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
  m.MaxNestedLoop > 3 ||       // http://www.cppdepend.com/Metrics.aspx#NbILInstructions
  m.CyclomaticComplexity > 20 ||    // http://www.cppdepend.com/Metrics.aspx#CC
  m.NestingDepth > 5 ||           // http://www.cppdepend.com/Metrics.aspx#ILNestingDepth
  m.NbParameters > 5 ||             // http://www.cppdepend.com/Metrics.aspx#NbParameters
  m.NbVariables > 8 ||              // http://www.cppdepend.com/Metrics.aspx#NbVariables
  m.NbOverloads > 6                 // http://www.cppdepend.com/Metrics.aspx#NbOverloads

select new { m, m.NbLinesOfCode, m.MaxNestedLoop, m.CyclomaticComplexity, 
              m.NestingDepth, 
             m.NbParameters, m.NbVariables, m.NbOverloads } ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods too big</Name>
warnif count > 0 from m in JustMyCode.Methods where 
   m.NbLinesOfCode > 30 
   orderby m.NbLinesOfCode descending
           
select new { m, m.NbLinesOfCode}

// Methods where NbLinesOfCode > 30 
// are extremely complex and should be split in smaller methods.
// See the definition of the NbLinesOfCode metric here 
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods too complex</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.CyclomaticComplexity > 20 ||
  m.MaxNestedLoop > 3 ||
  m.NestingDepth > 5
  orderby m.CyclomaticComplexity descending,
          m.MaxNestedLoop descending,
          m.NestingDepth descending
select new { m, m.CyclomaticComplexity, 
                m.MaxNestedLoop,
                m.NestingDepth  }

// Methods where CyclomaticComplexity > 20 
// or MaxNestedLoop > 40
// or NestingDepth > 4
// are hard to understand and maintain
// and should be split in smaller methods.
// See the definition of the complexity metrics here:
// http://www.cppdepend.com/Metrics.aspx#CC
// http://www.cppdepend.com/Metrics.aspx#ILCC
// http://www.cppdepend.com/Metrics.aspx#ILNestingDepth]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods potentially poorly commented</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.PercentageComment < 20 && 
  m.NbLinesOfCode > 20  
  orderby m.PercentageComment ascending
select new { m, m.PercentageComment, m.NbLinesOfCode, m.NbLinesOfComment }

// Methods where %Comment < 20 and that have 
// at least 20 lines of code might need to be more commented.
// See the definition of the Comments metric here 
// http://www.cppdepend.com/Metrics.aspx#PercentageComment
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfComment ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods with too many parameters</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbParameters > 5 
  orderby m.NbParameters descending
select new { m, m.NbParameters }

// Methods where NbParameters > 5 might be painful to call 
// and might degrade performance. You should prefer using 
// additional properties/fields to the declaring type to 
// handle numerous states. Another alternative is to provide 
// a class or structure dedicated to handle arguments passing 
// See the definition of the NbParameters metric here 
// http://www.cppdepend.com/Metrics.aspx#NbParameters]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods with too many local variables</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbVariables > 15 
  orderby m.NbVariables descending
select new { m, m.NbVariables }

// Methods where NbVariables > 8 are hard to understand and maintain.
// Methods where NbVariables > 15 are extremely complex 
// and should be split in smaller methods.
// See the definition of the Nbvariables metric here 
// http://www.cppdepend.com/Metrics.aspx#Nbvariables]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods with too many overloads</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbOverloads > 6 && 
  !m.IsOperator // Don't report operator overload
  orderby m.NbOverloads descending
select new { m, m.NbOverloads }

// Methods where NbOverloads > 6 might 
// be a problem to maintain and provoke higher coupling 
// than necessary. 
// This might also reveal a potential misused of the 
// C# and VB.NET language that since C#3 and VB9 support 
// object initialization. This feature helps reducing the number 
// of constructors of a class.
// See the definition of the NbOverloads metric here 
// http://www.cppdepend.com/Metrics.aspx#NbOverloads]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types with too many methods</Name>
warnif count > 0 from t in JustMyCode.Types where 
  t.Methods.Count() > 20 && !t.IsGlobal
  orderby t.Methods.Count() descending
select new { t, t.InstanceMethods, t.StaticMethods }

// Types where Methods.Count() > 20 might be hard to 
// understand and maintain 
// but there might be cases where it is relevant 
// to have a high number of methods. 
// For example, the System.Windows.Forms.DataGridView 
// standard class has more than 1000 methods.
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types with too many fields</Name>
warnif count > 0 from t in JustMyCode.Types where 
  t.Fields.Count() > 20 && 
  !t.IsEnumeration && !t.IsGlobal
  orderby t.Fields.Count() descending
select new { t, t.InstanceFields, t.StaticFields}

// Types where Fields.Count() > 20 and not IsEnumeration 
// might be hard to understand and maintain 
// but there might be cases where it is relevant 
// to have a high number of fields. 
// For example, the System.Windows.Forms.Control 
// standard class has more than 200 fields.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types with poor cohesion</Name>
warnif count > 0 from t in JustMyCode.Types where 
  (t.LCOM > 0.8 || t.LCOMHS > 0.95) && 
  t.NbFields > 10 && 
  t.NbMethods >10 && !t.IsGlobal
  orderby t.LCOM descending, t.LCOMHS descending
select new { t, t.LCOM, t.LCOMHS, 
                t.NbMethods, t.NbFields }

// Types where LCOM > 0.8 and NbFields > 10 
// and NbMethods >10 might be problematic. 
// However, it is very hard to avoid such 
// non-cohesive types. The LCOMHS metric
// is often considered as more efficient to 
// detect non-cohesive types.
// See the definition of the LCOM metric here 
// http://www.cppdepend.com/Metrics.aspx#LCOM]]></Query>
    </Group>
    <Group Name="Code Quality Regression" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all methods added or refactored should respect basic quality principles</Name>
warnif count > 0 from m in JustMyCode.Methods where

// *** Only new or modified methods since Baseline for Comparison ***
 (m.WasAdded() || m.CodeWasChanged()) &&
 
// Low Quality methods// Metrics' definitions
(  m.NbLinesOfCode > 30 ||          // http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
   m.CyclomaticComplexity > 20 ||   // http://www.cppdepend.com/Metrics.aspx#CC
   m.MaxNestedLoop > 50 || // http://www.cppdepend.com/Metrics.aspx#ILCC
   m.NestingDepth > 4 ||          // http://www.cppdepend.com/Metrics.aspx#ILNestingDepth
   m.NbParameters > 5 ||            // http://www.cppdepend.com/Metrics.aspx#NbParameters
   m.NbVariables > 8 ||             // http://www.cppdepend.com/Metrics.aspx#NbVariables
   m.NbOverloads > 6 )
select new { m, m.NbLinesOfCode, m.CyclomaticComplexity, 
             m.MaxNestedLoop, m.NestingDepth, 
             m.NbParameters, m.NbVariables, m.NbOverloads }  // http://www.cppdepend.com/Metrics.aspx#NbOverloads


// This rule warns if a method with
// low-quality has been added or refactored.
// With CppDepend and such rule, you can
// Ensure Quality From Now!
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all types added or refactored should respect basic quality principles</Name>
warnif count > 0 from t in JustMyCode.Types where

// *** Only match new or modified types since Baseline for Comparison ***
(t.WasAdded() || t.CodeWasChanged()) &&

// Eliminate interfaces, enumerations or types only with constant fields
// by making sure we are matching type with code.
t.NbLinesOfCode > 10 &&

// Low Quality types     Metrics' definitions are available here:
//     http://www.cppdepend.com/Metrics.aspx#MetricsOnTypes
(  // Types with too many methods
   t.NbMethods > 20 ||

   // Types with too many fields
   t.NbFields > 20 ||

   // Complex Types that use more than 50 other types
   t.NbTypesUsed > 50
)
select new { t, t.Methods, t.Fields, t.TypesUsed }


// This rule warns if a type with
// low-quality has been added or refactored.
// With CppDepend and such rule, you can
// Ensure Quality From Now!
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid making complex methods even more complex (Source CC)</Name>
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

warnif count > 0 
from m in JustMyCode.Methods where
 !m.IsAbstract &&
  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged()

let oldCC = m.OlderVersion().CyclomaticComplexity
where oldCC > 6 && m.CyclomaticComplexity > oldCC 

select new { m,
    oldCC ,
    newCC = m.CyclomaticComplexity ,
    oldLoc = m.OlderVersion().NbLinesOfCode,
    newLoc = m.NbLinesOfCode,
}
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid making large methods even larger</Name>
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

warnif count > 0 
from m in JustMyCode.Methods where
 !m.IsAbstract &&
  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged() &&
 // Eliminate constructors from match, since they get larger
 // as soons as some fields initialization are added.
 !m.IsConstructor &&
 !m.IsDestructor

let oldLoc = m.OlderVersion().NbLinesOfCode
where oldLoc > 15 && m.NbLinesOfCode > oldLoc

select new { m,
    oldLoc,
    newLoc = m.NbLinesOfCode,
}

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid adding methods to a type that already had many methods</Name>
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

warnif count > 0 
from t in JustMyCode.Types where
  t.IsPresentInBothBuilds() &&
  t.Methods.Count() > t.OlderVersion().Methods.Count() &&
  t.OlderVersion().Methods.Count() > 10

let newMethods = t.Methods.Where(m => m.WasAdded())
let removedMethods = t.OlderVersion().Methods.Where(m => m.WasRemoved())

select new { t,
             oldNbMethods = t.OlderVersion().NbMethods,
             newNbMethods = t.NbMethods,
             newMethods,
             removedMethods  }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid adding instance fields to a type that already had many instance fields</Name>
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

warnif count > 0 
from t in JustMyCode.Types where
  t.IsPresentInBothBuilds() &&
 !t.IsStatic

let oldNbInstanceFields = t.OlderVersion().InstanceFields
let newNbInstanceFields = t.InstanceFields
where
  newNbInstanceFields.Count() > oldNbInstanceFields .Count() &&
  oldNbInstanceFields.Count() > 6

let newInstanceFields = t.InstanceFields.Where(f => f.WasAdded())

select new { t,
             oldCount = oldNbInstanceFields.Count() ,
             newCount = newNbInstanceFields.Count() ,
             newInstanceFields }]]></Query>
    </Group>
    <Group Name="Object Oriented Design" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Base class should not use derivatives</Name>
warnif count > 0 
from baseClass in JustMyCode.Types
where baseClass.IsClass && baseClass.NbChildren > 0 // <-- for optimization!
let derivedClassesUsed = baseClass.DerivedTypes.UsedBy(baseClass)
where derivedClassesUsed.Count() > 0
select new { baseClass, derivedClassesUsed }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Class shouldn't be too deep in inheritance tree</Name>
warnif count > 0 from t in JustMyCode.Types 
where t.IsClass
&& t.DepthOfInheritance >= 5

select new { t, 
                t.DepthOfInheritance } 

// Branches too long in the derivation should be avoided.
// See the definition of the DepthOfInheritance metric here 
// http://www.cppdepend.com/Metrics.aspx#DIT
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Constructor should not call a virtual methods</Name>

// Returns constructor of a non-sealed type calling virtual methods.
// In such a situation, if a derived class overrides the method,
// then the override method will be called before the derived constructor.
// This makes the class fragile to derive from.
//
// Violations reported can be solved by re-designing object initialisation
// or by marking the parent class as sealed, if possible.

warnif count > 0
from t in Application.Types where 
   t.IsClass &&
  !t.IsGeneratedByCompiler

from ctor in t.Constructors 
let virtualMethodsCalled = from mCalled in ctor.MethodsCalled
                           where mCalled.IsVirtual &&
                                (mCalled.ParentType == t ||
                                 t.DeriveFrom(mCalled.ParentType))
                           select mCalled
where virtualMethodsCalled.Count() > 0

select new { ctor , 
             virtualMethodsCalled, 
             // If there is no derived type, it might be 
             // an opportunity to mark t as sealed.
             t.DerivedTypes }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid the Singleton pattern</Name>
warnif count > 0
from t in Application.Types
where !t.IsStatic && !t.IsAbstract && (t.IsClass || t.IsStructure)

// All ctors of a singleton are private
where t.Constructors.Where(ctor => !ctor.IsPrivate).Count() == 0

// A singleton contains one static field of its parent type, to reference the unique instance
let staticFieldInstances = t.StaticFields.WithFieldType(t)
where staticFieldInstances.Count() == 1
select new { t, staticFieldInstance = staticFieldInstances.First() }

// The Singleton pattern consists in syntactically enforcing that a class 
// has just one unique instance.
// At first glance, this pattern looks appealing and it is widely used.
// However, we discourage you from using singleton classes because experience
// shows that singletons often result in less testable and less maintainable code.
// More details available in these discussions:
//  http://codebetter.com/patricksmacchia/2011/05/04/back-to-basics-usage-of-static-members/
//  http://adamschepis.com/blog/2011/05/02/im-adam-and-im-a-recovering-singleton-addict/
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Don't assign static fields from instance methods</Name>
// Assigning static fields from instance methods leads to
// poorly maintainable and non thread-safe code.
// It is advised to assign static fields inline or from class constructor.
warnif count > 0
from f in Application.Fields where 
  f.IsStatic &&
 !f.IsGeneratedByCompiler && !f.IsGlobal
 
let assignedBy = f.MethodsAssigningMe.Where(m => !m.IsStatic && !m.IsGlobal)
where assignedBy .Count() > 0
select new { f, assignedBy }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid Abstract Classes with too many methods</Name>
// An abstract class  should abstract a clear and well-defined concept.
// Such concept shoudln't be represented with too many methods and property getter.
warnif count > 0 from t in JustMyCode.Types where 
  t.IsAbstract
let methodsAndGetters = t.Methods
where methodsAndGetters.Count() > 10
select new { t, methodsAndGetters }]]></Query>
    </Group>
    <Group Name="Design" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Type should not have too many responsibilities</Name>
// Types using more than 8 different application namespaces 
// are considered as having too many responsabilities.
warnif count > 0 

from t in JustMyCode.Types 
let applicationTypesUsed = t.TypesUsed.ExceptThirdParty().ToList()
let applicationNamespacesUsed = applicationTypesUsed.ParentNamespaces().ToList()
where applicationNamespacesUsed.Count > 8

// Use an empiric formula to sort by degree of responsabilities
let responsabilitiesMetric = (10 * applicationNamespacesUsed.Count + applicationTypesUsed.Count)/10
orderby responsabilitiesMetric descending

select new { t, applicationNamespacesUsed, applicationTypesUsed, responsabilitiesMetric } 


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Nested types should not be visible</Name>
warnif count > 0 from t in JustMyCode.Types where 
  t.IsNested && 
 !t.IsGeneratedByCompiler &&
 !t.IsPrivate 
select new { t, t.NbLinesOfCode, t.Visibility } 


// A nested type is a type declared within the 
// scope of another type. Nested types are useful 
// for encapsulating private implementation details 
// of the containing type. Used for this purpose, 
// nested types should not be externally visible. 
// Do not use externally visible nested types for 
// logical grouping or to avoid name collisions; 
// instead, use namespaces.]]></Query>
    </Group>
    <Group Name="Architecture and Layering" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid namespaces mutually dependent</Name>
warnif count > 0
// Foreach pair of namespace mutually dependent, this rule lists pairs.
// The pair { first, second } is formatted to show that first namespace shouldn't use the second namespace.
// The first/second order is inferred from the number of types used by each other.
// The first namespace is using less types of the second.
// It means that the first namespace is certainly at a lower level in the architecture, than the second.
// To explore the coupling between the two namespaces, you can export:
//  - typesOfFirstUsedBySecond to the vertical header of the dependency matrix
//  - typesOfSecondUsedByFirst to the horizontal header of the dependency matrix
//



// Optimization: restreint application Projects set
// If some namespaces are mutually dependent
//  - They must be declared in the same project
//  - The parent project must ContainsNamespaceDependencyCycle
from project in Application.Projects.Where(a => a.ContainsNamespaceDependencyCycle != null && a.ContainsNamespaceDependencyCycle.Value)

// hashset is used to avoid reporting both A <-> B and B <-> A
let hashset = new HashSet<INamespace>()

// Optimization: restreint namespaces set
// If a namespace doesn't have a Level value, it must be in a dependency cycle
// or it must be using directly or indirectly a dependency cycle.
let namespacesSuspect = project.ChildNamespaces.Where(n => n.Level == null && n.Name!="")

from nA in namespacesSuspect

// Select namespaces mutually dependent with nA
let unused = hashset.Add(nA) // Populate hashset
let namespacesMutuallyDependentWith_nA = nA.NamespacesUsed.Using(nA)
          .Except(hashset) // <-- avoid reporting both A <-> B and B <-> A 
where namespacesMutuallyDependentWith_nA.Count() > 0

from nB in namespacesMutuallyDependentWith_nA

// nA and nB are mutually dependent
// Select first the one that shouldn't use the other.
// The first namespace is inferred from the fact that it is using less types of the second.
let typesOfBUsedByA = nB.ChildTypes.UsedBy(nA)
let typesOfAUsedByB = nA.ChildTypes.UsedBy(nB)
let first = (typesOfBUsedByA.Count() > typesOfAUsedByB.Count()) ? nB : nA
let second = (first == nA) ? nB : nA
let typesOfFirstUsedBySecond = (first == nA) ? typesOfAUsedByB : typesOfBUsedByA
let typesOfSecondUsedByFirst = (first == nA) ? typesOfBUsedByA : typesOfAUsedByB
where typesOfFirstUsedBySecond.Count()>0 && typesOfSecondUsedByFirst.Count()>0
select new { first, shouldntUse = second, typesOfFirstUsedBySecond, typesOfSecondUsedByFirst }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid namespaces dependency cycles</Name>
warnif count > 0
// This query lists all application namespaces dependency cyles.
// Each row shows a different cycle, prefixed with a namespace entangled in the cycle.
//
// To browse a cycle on the dependency graph or the dependency matrix, just right click
// a cycle cell and export namespaces matched to the dependency graph or matrix!
//
// In the matrix, dependency cycles are represented with red squares and black cells.
// To browse easily dependency cycles, the Matrix comes with the option:
//   --> Display Direct and Indirect Dependencies
//



// Optimization: restreint application Projects set
// If some namespaces are mutually dependent
//  - They must be declared in the same project
//  - The parent project must ContainsNamespaceDependencyCycle
from project in Application.Projects
                 .Where(a => a.ContainsNamespaceDependencyCycle != null && 
                             a.ContainsNamespaceDependencyCycle.Value)

// Optimization: restreint namespaces set
// A namespace involved in a cycle necessarily have a null Level.
let namespacesSuspect = project.ChildNamespaces.Where(n => n.Level == null && n.Name!="")

// hashset is used to avoid iterating again on namespaces already caught in a cycle.
let hashset = new HashSet<INamespace>()


from suspect in namespacesSuspect
   // By commenting this line, the query matches all namespaces involved in a cycle.
   where !hashset.Contains(suspect)

   // Define 2 code metrics
   // - Namespaces depth of is using indirectly the suspect namespace.
   // - Namespaces depth of is used by the suspect namespace indirectly.
   // Note: for direct usage the depth is equal to 1.
   let namespacesUserDepth = namespacesSuspect.DepthOfIsUsing(suspect)
   let namespacesUsedDepth = namespacesSuspect.DepthOfIsUsedBy(suspect)

   // Select namespaces that are both using and used by namespaceSuspect
   let usersAndUsed = from n in namespacesSuspect where 
                         namespacesUserDepth[n] > 0 && 
                         namespacesUsedDepth[n] > 0 
                      select n

   where usersAndUsed.Count() > 0

   // Here we've found namespace(s) both using and used by the suspect namespace.
   // A cycle involving the suspect namespace is found!
   let cycle = usersAndUsed.Concat(new[] { suspect  })

   // Fill hashset with namespaces in the cycle.
   // .ToArray() is needed to force the iterating process.
   let unused1 = (from n in cycle let unused2 = hashset.Add(n) select n).ToArray()

select new { suspect, cycle }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects with poor cohesion (RelationalCohesion)</Name>
warnif count > 0 from a in Application.Projects where 
  a.NbTypes > 20 && // Relational Cohesion metrics is relevant only if there are several types 
  (a.RelationalCohesion < 1.5 || 
   a.RelationalCohesion > 4.0)
select new { a, a.NbTypes, a.RelationalCohesion }

// As classes inside an project should be strongly related, 
// the cohesion should be high. On the other hand, a value 
// which is too high may indicate over-coupling. A good range 
// for RelationalCohesion is 1.5 to 4.0.
// See the definition of the RelationalCohesion metric here 
// http://www.cppdepend.com/Metrics.aspx#RelationalCohesion]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects that don't satisfy the Abstractness/Instability principle</Name>
warnif percentage > 15 from a in Application.Projects where 
  a.NormDistFromMainSeq > 0.7 
  orderby a.NormDistFromMainSeq descending
select new { a, a.NormDistFromMainSeq }

// See the definition of the NormDistFromMainSeq metric here 
// http://www.cppdepend.com/Metrics.aspx#DitFromMainSeq]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Example of custom rule to check for dependency</Name>

// To define a rule that warns if a particular dependency exist or not, 
// from a code element A to a code element B
// A and B being an project Namespace Type Method or Field,
// A and B not necessarily two Projects or two Namespaces...
// you can first, right click the cell in the Dependency Matrix
// with B in row and A in column,
// or right-click the concerned arrow in the Dependency Graph
// from A to B, and choose to: 
// "Generate a code rule that warns if this dependency exists"
//
// The generated rule will look like the one below.
// It is now up to you to adapt this rule to check your needs.

warnif count > 0 from a in Projects
where 
a.IsUsing("Foo1.Foo2".AllowNoMatch().MatchNamespace()) &&
(a.Name == @"Foo3")
select new { a, a.NbLinesOfCode }
// the project Foo3
// shouldn't use directly 
// the namespace Foo3.Foo4
// because (TODO insert your reason)
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Higher cohesion - lower coupling</Name>
// It is deemed as a good software architecture practice to clearly separate
// 'abstract' namespaces containing only abstractions (interfaces, enumerations, delegates)
// from other 'concrete' namespaces, that contains classes and structures.
//
// Typically, the more concrete namespaces rely on abstract namespaces *only*,
// the more Decoupled is the architecture, and the more Cohesive are 
// classes inside concrete namespaces.
//
// The following code query, define sets of abstract and concrete namespaces
// and shows for each concrete namespaces, which concrete and abstract namespaces are used.
// 
// This query can be adapted to a rule, depending on how much you want
// your code architecture being decoupled.
//

let abstractNamespaces = JustMyCode.Namespaces.Where(
     n => n.ChildTypes.Where(t => !t.IsInterface && !t.IsEnumeration ).Count() == 0
).ToHashSet()

let concreteNamespaces = JustMyCode.Namespaces.Except(abstractNamespaces).ToHashSet()

from n in concreteNamespaces
let namespacesUsed = n.NamespacesUsed.ExceptThirdParty()
let concreteNamespacesUsed = namespacesUsed.Except(abstractNamespaces)
let abstractNamespacesUsed = namespacesUsed.Except(concreteNamespaces)
select new { n, concreteNamespacesUsed , abstractNamespacesUsed }]]></Query>
    </Group>
    <Group Name="Diagnostics Queries" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>All diagnostics</Name> 
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang"
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Preprocessor issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("_pp_")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Cast issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("cast")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Conversion Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("conversion")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Deprecated Usage</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("deprecated")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Unused Symbols</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("unused")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Switch Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && (issue.Type.Contains("switch") || issue.Type.Contains("case"))
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Delete Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("delete")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Struct Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("_struct")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Enum Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("_enum_")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Template Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("template")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Comparison Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("comparison")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>OpenMP Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("_omp_")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
    </Group>
    <Group Name="API Breaking Changes" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Types</Name>
// This rule warns if a publicly visible type is 
// not publicly visible anymore or if it has been removed.
// Such type can break the code of your clients.

warnif count > 0 from t in codeBase.OlderVersion().Application.Types
where t.IsPublic && 

     // The type has been removed and its parent project hasn't been removed ...
     ( (t.WasRemoved() && !t.ParentProject.WasRemoved()) ||

     // ... or the type is not publicly visible anymore
       !t.WasRemoved() && !t.NewerVersion().IsPublic)

select new { t,
             NewVisibility = (t.WasRemoved() ? " " : t.NewerVersion().Visibility.ToString()) }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Methods</Name>
// This rule warns if a publicly visible method is 
// not publicly visible anymore or if it has been removed.
// Such method can break the code of your clients.

warnif count > 0 from m in codeBase.OlderVersion().Application.Methods
where m.IsPublic && 

     // The method has been removed and its parent type hasn't been removed ...
     ( (m.WasRemoved() && !m.ParentType.WasRemoved()) ||

     // ... or the method is not publicly visible anymore
       !m.WasRemoved() && !m.NewerVersion().IsPublic)

select new { m,
             NewVisibility = (m.WasRemoved() ? " " : m.NewerVersion().Visibility.ToString()) }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Fields</Name>
// This rule warns if a publicly visible field is 
// not publicly visible anymore or if it has been removed.
// Such field can break the code of your clients.

warnif count > 0 from f in codeBase.OlderVersion().Application.Fields
where f.IsPublic &&

     // The field has been removed and its parent type hasn't been removed ...
     ( (f.WasRemoved() && !f.ParentType.WasRemoved()) ||

     // ... or the field is not publicly visible anymore
       !f.WasRemoved() && !f.NewerVersion().IsPublic)

select new { f,
             NewVisibility = (f.WasRemoved() ? " " : f.NewerVersion().Visibility.ToString()) }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Interfaces and Abstract Classes</Name>
// This rule warns if a publicly visible interface or abstract class 
// has been changed and contains new abstract methods or 
// if some abstract methods have been removed.
// This can break the code of clients 
// that implement such interface or derive from such abstract class.

warnif count > 0 from tNewer in Application.Types where 
 (tNewer.IsInterface || tNewer.IsClass && tNewer.IsAbstract) && 
  tNewer.IsPublic && 
  tNewer.IsPresentInBothBuilds()

let tOlder = tNewer.OlderVersion() where tOlder.IsPublic

let methodsRemoved = tOlder.Methods.Where(m => m.IsAbstract && m.WasRemoved())
let methodsAdded = tNewer.Methods.Where(m => m.IsAbstract && m.WasAdded())

where methodsAdded.Count() > 0 || methodsRemoved.Count() > 0
select new { tNewer, methodsAdded, methodsRemoved }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid transforming immutable types into mutable types</Name>

// Immutability is a strong property on a type.
// Breaking immutability can result in serious problem for an algorithm consummer
// that has been written taking account of the type immutability.

// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

warnif count > 0 
from t in Application.Types where
  t.IsPresentInBothBuilds() &&
 !t.IsStatic &&
 !t.IsImmutable && 
  t.OlderVersion().IsImmutable

let mutableFields = from f in t.InstanceFields where !f.IsImmutable select f

select new { t, mutableFields }

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>API: New publicly visible types</Name>
// List types that are new in the public surface of your Projects

from t in Application.Types
where t.IsPublic && 

     // The type has been removed and its parent project hasn't been removed ...
     ( (t.WasAdded() && !t.ParentProject.WasAdded()) ||

     // ... or the type existed but was not publicly visible
       !t.WasAdded() && !t.OlderVersion().IsPublic)

select new { t,
             OldVisibility = (t.WasAdded() ? " " : t.OlderVersion().Visibility.ToString()) }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>API: New publicly visible methods</Name>
// List methods that are new in the public surface of your Projects

from m in Application.Methods
where m.IsPublic && 

     // The method has been removed and its parent project hasn'm been removed ...
     ( (m.WasAdded() && !m.ParentType.WasAdded()) ||

     // ... or the t existed but was not publicly visible
       !m.WasAdded() && !m.OlderVersion().IsPublic)

select new { m,
             OldVisibility = (m.WasAdded() ? " " : m.OlderVersion().Visibility.ToString()) }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>API: New publicly visible fields</Name>
// List fields that are new in the public surface of your Projects

from f in Application.Fields
where f.IsPublic && 

     // The method has been removed and its parent project hasn'f been removed ...
     ( (f.WasAdded() && !f.ParentType.WasAdded()) ||

     // ... or the t existed but was not publicly visible
       !f.WasAdded() && !f.OlderVersion().IsPublic)

select new { f,
             OldVisibility = (f.WasAdded() ? " " : f.OlderVersion().Visibility.ToString()) }]]></Query>
    </Group>
    <Group Name="Code Diff Summary" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New Projects</Name>
from a in Application.Projects where a.WasAdded()
select new { a, a.NbLinesOfCode }

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects removed</Name>
from a in codeBase.OlderVersion().Application.Projects where a.WasRemoved()
select new { a, a.NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects where code was changed</Name>
from a in Application.Projects where a.CodeWasChanged()
select new { a, a.NbLinesOfCode, 
             oldNbLinesOfCode = a.OlderVersion().NbLinesOfCode ,
             delta = (int) a.NbLinesOfCode - a.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New namespaces</Name>
from n in Application.Namespaces where 
 !n.ParentProject.WasAdded() &&
  n.WasAdded()
select new { n, n.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces removed</Name>
from n in codeBase.OlderVersion().Application.Namespaces where 
 !n.ParentProject.WasRemoved() &&
  n.WasRemoved()
select new { n, n.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces where code was changed</Name>
from n in Application.Namespaces where n.CodeWasChanged()
select new { n, n.NbLinesOfCode, 
             oldNbLinesOfCode = n.OlderVersion().NbLinesOfCode ,
             delta = (int) n.NbLinesOfCode - n.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New types</Name>
from t in Application.Types where 
 !t.ParentNamespace.WasAdded() &&
  t.WasAdded()
select new { t, t.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types removed</Name>
from t in codeBase.OlderVersion().Application.Types where 
 !t.ParentNamespace.WasRemoved() &&
  t.WasRemoved()
select new { t, t.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types where code was changed</Name>
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

from t in Application.Types where t.CodeWasChanged() 
//select new { t, t.NbLinesOfCode }
select new { t, t.NbLinesOfCode, 
             oldNbLinesOfCode = t.OlderVersion().NbLinesOfCode ,
             delta = (int?) t.NbLinesOfCode - t.OlderVersion().NbLinesOfCode } 
/*from t in Application.Types where t.CodeWasChanged() && t.IsPresentInBothBuild
select new { t, t.NbLinesOfCode, 
             oldNbLinesOfCode = t.OlderVersion().NbLinesOfCode ,
             delta = (int) t.NbLinesOfCode - t.OlderVersion().NbLinesOfCode }*/]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Heuristic to find types moved from one namespace or project to another</Name>
let typesRemoved = codeBase.OlderVersion().Types.Where(t => t.WasRemoved())
let typesAdded = Types.Where(t => t.WasAdded())

from tMoved in typesAdded.Join(
   typesRemoved,
   t => t.Name,
   t => t.Name,
   (tNewer, tOlder) => new { tNewer, 
                             OlderParentNamespace = tOlder.ParentNamespace,
                             OlderParentproject = tOlder.ParentProject  } ) 
select tMoved]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types directly using one or several types changed</Name>
let typesChanged = Application.Types.Where(t => t.CodeWasChanged()).ToHashSet()

from t in JustMyCode.Types.UsingAny(typesChanged) where
  !t.CodeWasChanged() && 
  !t.WasAdded()
let typesChangedUsed = t.TypesUsed.Intersect(typesChanged) 
select new { t, typesChangedUsed }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types indirectly using one or several types changed</Name>
let typesChanged = Application.Types.Where(t => t.CodeWasChanged()).ToHashSet()

// 'depth' represents a code metric defined on types using
// directly or indirectly any type where code was changed.
let depth = JustMyCode.Types.DepthOfIsUsingAny(typesChanged) 

from t in depth.DefinitionDomain where
  !t.CodeWasChanged() && 
  !t.WasAdded()

let typesChangedDirectlyUsed = t.TypesUsed.Intersect(typesChanged) 
let depthOfUsingTypesChanged = depth[t]
orderby depthOfUsingTypesChanged 

select new { t, depthOfUsingTypesChanged, typesChangedDirectlyUsed }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New methods</Name>
from m in Application.Methods where 
 !m.ParentType.WasAdded() &&
  m.WasAdded()
select new { m, m.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods removed</Name>
from m in codeBase.OlderVersion().Application.Methods where 
 !m.ParentType.WasRemoved() &&
  m.WasRemoved()
select new { m, m.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods where code was changed</Name>
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

from m in Application.Methods where m.CodeWasChanged()
select new { m, m.NbLinesOfCode, 
             oldNbLinesOfCode = m.OlderVersion().NbLinesOfCode ,
             delta = (int?) m.NbLinesOfCode - m.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly calling one or several methods changed</Name>
let methodsChanged = Application.Methods.Where(m => m.CodeWasChanged()).ToHashSet()

from m in JustMyCode.Methods.UsingAny(methodsChanged ) where
  !m.CodeWasChanged() && 
  !m.WasAdded()
let methodsChangedCalled = m.MethodsCalled.Intersect(methodsChanged) 
select new { m, methodsChangedCalled }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods indirectly calling one or several methods changed</Name>
let methodsChanged = Application.Methods.Where(m => m.CodeWasChanged()).ToHashSet()

// 'depth' represents a code metric defined on methods using
// directly or indirectly any method where code was changed.
let depth = JustMyCode.Methods.DepthOfIsUsingAny(methodsChanged) 

from m in depth.DefinitionDomain where
  !m.CodeWasChanged() && 
  !m.WasAdded()

let methodsChangedDirectlyUsed = m.MethodsCalled.Intersect(methodsChanged) 
let depthOfUsingMethodsChanged = depth[m]
orderby depthOfUsingMethodsChanged 

select new { m, depthOfUsingMethodsChanged, methodsChangedDirectlyUsed }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New fields</Name>
from f in Application.Fields where 
 !f.ParentType.WasAdded() &&
  f.WasAdded()
select new { f }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields removed</Name>
from f in codeBase.OlderVersion().Application.Fields where 
 !f.ParentType.WasRemoved() &&
  f.WasRemoved()
select new { f }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party types that were not used and that are now used</Name>
from t in ThirdParty.Types where t.IsUsedRecently()
select new { t, t.Methods, t.Fields } 
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party types that were used and that are not used anymore</Name>
from t in codeBase.OlderVersion().Types where t.IsNotUsedAnymore()
select new { t, t.Methods, t.Fields }  
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party methods that were not used and that are now used</Name>
from m in ThirdParty.Methods where 
  m.IsUsedRecently() &&
 !m.ParentType.IsUsedRecently()
select m]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party methods that were used and that are not used anymore</Name>
from m in codeBase.OlderVersion().Methods where 
  m.IsNotUsedAnymore() &&
 !m.ParentType.IsNotUsedAnymore()
select m]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party fields that were not used and that are now used</Name>
from f in ThirdParty.Fields where 
  f.IsUsedRecently() &&
 !f.ParentType.IsUsedRecently()
select f]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party fields that were used and that are not used anymore</Name>
from f in codeBase.OlderVersion().Fields where 
  f.IsNotUsedAnymore() &&
 !f.ParentType.IsNotUsedAnymore()
select f
]]></Query>
    </Group>
    <Group Name="Dead Code" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Potentially dead Types</Name>
warnif count > 0

let tt=Types.UsedByAny(Application.Methods).ToHashSet()
// Select types unused
let typesUnused = 
   from t in JustMyCode.Types where
   t.NbTypesUsingMe == 0 && !t.IsGlobal  select t



from t in typesUnused  where !tt.Contains(t)
select new { t }
        
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Potentially dead Methods</Name>
warnif count > 0
// Filter procedure for methods that should'nt be considered as dead
let canMethodBeConsideredAsDeadProc = new Func<IMethod, bool>(
    m => !m.IsPublic &&       // Public methods might be used by client applications of your Projects.
         !m.IsEntryPoint &&            // Main() method is not used by-design.
         !m.IsClassConstructor &&      
         !m.IsVirtual &&               // Only check for non virtual method that are not seen as used in IL.
         !(m.IsConstructor &&          // Don't take account of protected ctor that might be call by a derived ctors.
           m.IsProtected) &&
         !m.NameLike (@"^On") &&        //Exclude Events like MFC ones
         !m.IsGeneratedByCompiler
)

// Get methods unused
let methodsUnused = 
   from m in JustMyCode.Methods where 
   m.NbMethodsCallingMe == 0 && 
   canMethodBeConsideredAsDeadProc(m)
   select m

// Dead methods = methods used only by unused methods (recursive)
let deadMethodsMetric = methodsUnused.FillIterative(
   methods => // Unique loop, just to let a chance to build the hashset.
              from o in new[] { new object() }
              // Use a hashet to make Intersect calls much faster!
              let hashset = methods.ToHashSet()
              from m in codeBase.Application.Methods.UsedByAny(methods).Except(methods)
              where canMethodBeConsideredAsDeadProc(m) &&
                    // Select methods called only by methods already considered as dead
                    hashset.Intersect(m.MethodsCallingMe).Count() == m.NbMethodsCallingMe
              select m)

from m in JustMyCode.Methods.Intersect(deadMethodsMetric.DefinitionDomain)
select new { m, m.MethodsCallingMe, depth = deadMethodsMetric[m] }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Potentially dead Fields</Name>
warnif count > 0
from f in JustMyCode.Fields where
   f.NbMethodsUsingMe == 0 && 
   !f.IsPublic &&     // Although not recommended, public fields might be used by client applications of your Projects.
   !f.IsEnumValue   
  
   // If you don't want to link CppDepend.API.dll, you can use your own IsNotDeadCodeAttribute and adapt this rule.
select f]]></Query>
    </Group>
    <Group Name="Modernize C++ Code (You must enable this feature to have results)" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use auto specifier</Name>
 from issue in Issues where issue.ToolName=="Modernize" 
&& issue.Type=="auto"
select new { issue,issue.FilePath,Line=issue.BeginLine }
//This query search for places to use the auto type specifier 
//for variable declarations to improve code readability and maintainability.
//For more details you can refer to http://clang.llvm.org/extra/UseAutoTransform.html      

//N.B.: The Modernize feature must be enabled to have result. 
//You can enable it from "Project properties"=> Analysis=>Modernize C++ Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 

         ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use nullptr</Name>
 from issue in Issues where issue.ToolName=="Modernize" 
&& issue.Type=="null"
select new { issue,issue.FilePath,Line=issue.BeginLine }
//This query search for the null pointer constants (eg. NULL, 0) 
//to replace with the new C++11 nullptr keyword.
//For more details you can refer to http://clang.llvm.org/extra/UseNullptrTransform.html      

//N.B.: The Modernize feature must be enabled to have result. 
//You can enable it from "Project properties"=> Analysis=>Modernize C++ Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 

       ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize loops</Name>
 from issue in Issues where issue.ToolName=="Modernize" 
&& issue.Type=="loop"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This query searh for loops like for(...; ...; ...)  
//to use the new range-based loops in C++11. 
//For more details you can refer to http://clang.llvm.org/extra/LoopConvertTransform.html
       
//N.B.: The Modernize feature must be enabled to have result. 
//You can enable it from "Project properties"=> Analysis=>Modernize C++ Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 
         
         ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use unique_ptr instead of auto_ptr</Name>
 from issue in Issues where issue.ToolName=="Modernize" 
&& issue.Type=="autoptr"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This query searh for the uses of the deprecated class std::auto_ptr
//to replace by std::unique_ptr . 
//For more details you can refer to http://clang.llvm.org/extra/ReplaceAutoPtrTransform.html

//N.B.: The Modernize feature must be enabled to have result. 
//You can enable it from "Project properties"=> Analysis=>Modernize C++ Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 
         
         
         ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use override keyword</Name>
 from issue in Issues where issue.ToolName=="Modernize" 
&& issue.Type=="override"
select new { issue,issue.FilePath,Line=issue.BeginLine }
//This query search for places where you can add the override specifier 
//to member functions that override a virtual function
//in a base class and that dont already have the specifier
//For more details you can refer to http://clang.llvm.org/extra/AddOverrideTransform.html   

//N.B.: The Modernize feature must be enabled to have result. 
//You can enable it from "Project properties"=> Analysis=>Modernize C++ Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 
             
         ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Pass By Value</Name>
 from issue in Issues where issue.ToolName=="Modernize" 
&& issue.Type=="byvalue"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This query search places where you can use the pass-by-value idiom.
//For more details you can refer to http://clang.llvm.org/extra/PassByValueTransform.html      

//N.B.: The Modernize feature must be enabled to have result. 
//You can enable it from "Project properties"=> Analysis=>Modernize C++ Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results. 

              
     ]]></Query>
    </Group>
    <Group Name="Visibility" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields should be declared as private</Name>
warnif count > 0 from f in Application.Fields where 
 !f.IsPrivate && 

 // These conditions filter cases where fields 
 // doesn't represent state that should be encapsulated. 
 !f.IsGeneratedByCompiler && 
 !f.IsEnumValue
select new { f }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Constructors of abstract classes should be declared as protected or private</Name>
// Constructors of an abstract class can only be accessed from this class and derived class.
// Declaring such a constructor with another visibility level is useless and potentially misleading.

warnif count > 0
from t in Application.Types where 
  t.IsClass && 
  t.IsAbstract
let ctors = t.Constructors.Where(c => !c.IsProtected && !c.IsPrivate)
where ctors.Count() > 0
select new { t, ctors }

// Notice that if a constructor of an abstract class is declared as private,
// it can only be accessed from derived classes nested in the abstract class.]]></Query>
    </Group>
    <Group Name="Purity - Immutability - Constness" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Structures should be immutable</Name>
warnif count > 0 from t in Application.Types where 
   t.IsStructure && 
  !t.IsImmutable

let mutableFields = t.Fields.Where(f => !f.IsImmutable)

select new { t, t.NbLinesOfCode, mutableFields }

// It is deemed as a good practice to make 
// your structure immutable.
// An object is immutable if its state doesnt 
// change once the object has been created. 
// Consequently, a structure is immutable if 
// its instances are immutable.
// Immutable types naturally simplify code by 
// limiting side-effects.
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid static fields with a mutable field type</Name>
warnif count > 0
from f in Application.Fields
where f.IsStatic && !f.IsEnumValue && !f.IsGeneratedByCompiler
let fieldType = f.FieldType
where fieldType != null && 
     !fieldType.IsThirdParty && 
     !fieldType.IsInterface && 
     !fieldType.IsImmutable
select new { f, 
             mutableFieldType = fieldType , 
             isFieldImmutable = f.IsImmutable }


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>A field must not be assigned from outside its parent hierarchy types</Name>
warnif count > 0
from f in JustMyCode.Fields.Where(f => 
      !f.IsPrivate && !f.IsGeneratedByCompiler && 
      !f.IsImmutable && !f.IsEnumValue)

let methodsAssignerOutsideOfMyType = f.MethodsAssigningMe.Where(
        m =>!m.IsGeneratedByCompiler &&
             m.ParentType != f.ParentType && 
            !m.ParentType.DeriveFrom(f.ParentType) )

where methodsAssignerOutsideOfMyType.Count() > 0
select new { f, methodsAssignerOutsideOfMyType }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[
          // <Name>Use const_cast carrefully</Name>
          warnif count >0 (from m in Methods where m.IsUsing ("Keywords.const_cast")
          select new { m, m.NbLinesOfCode }).Take(10)
          ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[
          // <Name>Use mutable variable carrefuly</Name>
          warnif count >0  (from f in Fields where f.IsMutable
          select new { f }).Take(10)
          ]]></Query>
    </Group>
    <Group Name="Naming Conventions" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Instance fields should be prefixed with a 'm_'</Name>
warnif count > 0 (from f in Fields where 
  !f.NameLike (@"^m_") && 
  !f.IsStatic  
  // Don't hesitate to customize the regex of NameLike to your preference. 
 && !f.IsGlobal && !f.IsEnumValue && !f.IsThirdParty 
select new { f }).Take(10)
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Static fields should be prefixed with a 's_'</Name>
   warnif count > 0 (from f in Fields where 
  !f.NameLike (@"^s_") && 
  f.IsStatic && !f.IsThirdParty 
  select new { f }).Take(10)  
  // Don't hesitate to customize the regex of NameLike to your preference.


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Exception class name should be suffixed with 'Exception'</Name>
warnif count > 0 (from t in Types where t.IsExceptionClass && !t.NameLike (@"Exception$") && !t.IsThirdParty
select new { t, t.NbLinesOfCode }).Take(10)
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types name should begin with an Upper character</Name>
warnif count > 0 (from t in Types where 
 !t.NameLike (@"^[A-Z]")      // The name of a type should begin with an Upper letter.
  && // Except if it is generated by compiler or ...
 !t.IsThirdParty && !t.IsGlobal
select new { t, t.NbLinesOfCode }).Take(10)

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with name too long</Name>
warnif count > 0 from t in Application.Types 
where !t.IsGeneratedByCompiler && !t.IsThirdParty

where t.SimpleName.Length > 35 
select new { t, t.SimpleName }

      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with name too long</Name>
warnif count > 0 from m in Application.Methods where 
 !m.IsGeneratedByCompiler 
  && m.SimpleName.Length > 35 && !m.IsThirdParty

select new { m, m.SimpleName }

// The regex matches methods with name longer 
// than 35 characters.
// Method Name doesn't contain the type and namespace 
// prefix, FullName does.
// The regex computes the method name length from 
// the beginning until the first open parenthesis 
// or first lower than (for generic methods).
      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid fields with name too long</Name>
warnif count > 0 from f in Application.Fields where
 !f.IsGeneratedByCompiler &&
  f.Name.Length > 35 && !f.IsThirdParty
select f

// The regex matches fields with name longer 
// than 35 characters.
// Field Name doesn't contain the type and 
// namespace prefix, FullName does.
      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid naming types and namespaces with the same identifier</Name>

// Not only this can provoke compiler resolution collision,
// but also, this makes code less maintainable because
// concepts are not concisely identified.

warnif count > 0
let hashsetShortNames = Namespaces.Where(n => n.Name.Length > 0).Select(n => n.SimpleName).ToHashSet()

from t in JustMyCode.Types
where hashsetShortNames.Contains(t.Name) && !t.IsThirdParty
select new { t, namespaces = Namespaces.Where(n => n.SimpleName == t.Name) }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespace name should correspond to file location</Name>

// For a good code organization, 
// do mirror the namespaces hierarchy and the source files directories tree.

warnif count > 0
from n in Application.Namespaces 

// Replace dots by spaces in namespace name
let dirCorresponding = n.Name.Replace('.', ' ')

// Look at source file decl of JustMyCode type's declared in n
from t in n.ChildTypes
where JustMyCode.Contains(t) 
from decl in t.SourceDecls
let sourceFilePath = decl.SourceFile.FilePath.ToString()

// Replace dots and path separators by spaces in source files names
where !sourceFilePath.Replace('.',' ').Replace('\\',' ').Contains(dirCorresponding) && !t.IsThirdParty

select new { t, dirCorresponding , sourceFilePath  } ]]></Query>
    </Group>
    <Group Name="Source Files Organization" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid defining multiple types in a source file</Name>
warnif count > 0 

// Build a lookup indexed by source files, values being a sequence of types defined in the source file.
let lookup = Application.Types.Where(t => 
                                !t.IsGlobal && 
                               // except nested types and types generated by compilers!
                               !t.IsGeneratedByCompiler &&                               
                               !t.IsNested)                                
                         // It could make sense to not apply this rule for enumerations.
                         // && !t.IsEnumeration)

            // We use multi-key, since a type can be declared in multiple source files.
           .ToMultiKeyLookup(t => t.SourceDecls.Select(d => d.SourceFile))
 
from @group in lookup where @group.Count() > 1
   let sourceFile = @group.Key

   // CQLinq doesn't let indexing result with sourceFile 
   // so we choose a typeIndex in types, 
   // preferably the type that has the file name.
   let typeWithSourceFileName = @group.FirstOrDefault(t => t.SimpleName == sourceFile.FileNameWithoutExtension)
   let typeIndex = typeWithSourceFileName ?? @group.First()

select new { typeIndex, 
             types = @group as IEnumerable<IType>, 
             sourceFile.FilePathString }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespace name should correspond to file location</Name>

// For a good code organization, 
// do mirror the namespaces hierarchy and the source files directories tree.

warnif count > 0
from n in Application.Namespaces 

// Replace dots by spaces in namespace name
let dirCorresponding = n.Name.Replace('.', ' ')

// Look at source file decl of JustMyCode type's declared in n
from t in n.ChildTypes
where JustMyCode.Contains(t) && !t.IsGlobal
from decl in t.SourceDecls
let sourceFilePath = decl.SourceFile.FilePath.ToString()

// Replace dots and path separators by spaces in source files names
where !sourceFilePath.Replace('.',' ').Replace('\\',' ').Contains(dirCorresponding)

select new { t, dirCorresponding , sourceFilePath  } ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types with source files stored in the same directory, should be declared in the same namespace</Name>
warnif count > 0 

// Group JustMyCode types in a lookup 
// where groups are keyed with directories that contain the types' source file(s).
// Note that a type can be contained in several groups 
// if it is declared in several source files stored in different directories.
let lookup = JustMyCode.Types.Where(t => !t.IsGlobal)
            .ToMultiKeyLookup(
               t => t.SourceDecls.Select(
                          decl => decl.SourceFile.FilePath.ParentDirectoryPath).Distinct()
            )


from groupOfTypes in lookup
let parentNamespaces = groupOfTypes.ParentNamespaces()

// Select group of types (with source files stored in the same directory) ...
// ... but contained in several namespaces
where parentNamespaces.Count() > 1

// mainNamespaces is the namespace that contains many types 
// declared in the directory groupOfTypes .key
let mainNamespace  = groupOfTypes
                     .ToLookup(t => t.ParentNamespace)
                     .OrderByDescending(g => g.Count()).First().Key

// Select types with source files stored in the same directory,
// but contained in namespaces different than mainNamespace.
let typesOutOfMainNamespace = groupOfTypes
                              .Where(t => t.ParentNamespace != mainNamespace )

                               // Filter types declared on several source files that contain generated methods 
                               // because typically such type contains one or several partial definitions generated.
                               // These partially generated types would be false positive for the present rule.
                               .Where(t => t.SourceDecls.Count() == 1 ||
                                           t.Methods.Count(m => JustMyCode.Contains(m)) == 0)
where typesOutOfMainNamespace.Count() > 0

select new { mainNamespace, 

             // Typically a type in typesOutOfMainNamespace ...
             // 1) ... is contained in the wrong namespace but its source file(s) is stored in the right directory.
             //      --> In such situation the type should be contained in mainNamespace.
             // 2) ... is contained in the right namespace but its source file(s) is stored in the wrong directory
             //      --> In such situation the source file of type must be moved to the parent namespace directory.
             // 3) ... is declared in multiple source files, stored in different directories.
             //      --> It would be preferable that all source files are stored in a single directory.
             typesOutOfMainNamespace   }

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types declared in the same namespace, should have their source files stored in the same directory</Name>
warnif count > 0 
from @namespace in Application.Namespaces

// Group types of @namespace in a lookup 
// where groups are keyed with directories that contain the types' source file(s).
// Note that a type can be contained in several groups 
// if it is declared in several source files stored in different directories.
let lookup = @namespace.ChildTypes.Where(t => !t.IsGlobal && JustMyCode.Contains(t))
            .ToMultiKeyLookup(
               t => t.SourceDecls.Select(
                          decl => decl.SourceFile.FilePath.ParentDirectoryPath).Distinct()
            )

// Are types of @namespaces declared in more than one directory?
where lookup.Count > 1

// Infer the main directory, preferably the one that has the same name as the namespace.
let dirs = lookup.Select(types => types.Key)
let mainDirNullable = dirs.Where(d => d.DirectoryName == @namespace.SimpleName).FirstOrDefault()
let mainDir = mainDirNullable ?? dirs.First()

// Types declared out of mainDir, are types in group of types declared in a directory different than mainDir!
let typesDeclaredOutOfMainDir = lookup.Where(types => types.Key != mainDir)
                                .SelectMany(types => types)
                                
                                // Filter types declared on several source files that contain generated methods 
                                // because typically such type contains one or several partial definitions generated.
                                // These partially generated types would be false positive for the present rule.
                                .Where(t => t.SourceDecls.Count() == 1 ||
                                            t.Methods.Count(m => JustMyCode.Contains(m)) == 0)

where typesDeclaredOutOfMainDir.Count() > 0

select new { @namespace, 

             // Typically a type in typesDeclaredOutOfMainDir ...
             // 1) ... is contained in the wrong namespace but its source file(s) is stored in the right directory.
             //      --> In such situation the type parent namespace should be the namespace corresponding to the directory.
             // 2) ... is contained in the right namespace but its source file(s) is stored in the wrong directory
             //      --> In such situation the type source file should be moved to mainDir.
             // 3) ... is declared in multiple source files, stored in different directories.
             //      --> It would be preferable that all source files are stored in a single directory.
             typesDeclaredOutOfMainDir , 

             mainDir = mainDir.ToString() }]]></Query>
    </Group>
    <Group Name="Plugins" Active="True" ShownInReport="False">
      <Group Name="CppCheck Queries" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>All CppCheck Violations</Name>
warnif count>0          
from issue in Issues  where issue.ToolName=="CppCheck"
select new { issue,issue.FilePath,issue.BeginLine }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Classes violating CppCheck rules</Name>
(from t in Types where t.Issues.Where(i=>i.ToolName=="CppCheck").Count()>0
orderby t.Issues.Count() descending
select new { t,nbIssues=t.Issues.Count() }).Take(100)

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Methods violating CppCheck rules</Name>
(from m in Methods where m.Issues.Where(i=>i.ToolName=="CppCheck").Count()>0
orderby m.Issues.Count() descending
select new { m,nbIssues=m.Issues.Count() }).Take(100)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Project violating CppCheck rules</Name>
(from p in Projects where p.Issues.Where(i=>i.ToolName=="CppCheck").Count()>0
orderby p.Issues.Count() descending
select new { p,nbIssues=p.Issues.Count() }).Take(5)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Recurrent CppCheck violations</Name>
let groups = Application.Issues.Where(i=>i.ToolName=="CppCheck").GroupBy(t => t.Type)

from g in groups
orderby g.Count() descending
select new { issue=g.FirstOrDefault(),count=g.Count() }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Popular Methods violating CppCheck rules</Name>
(from m in Methods where m.Issues.Where(i=>i.ToolName=="CppCheck").Count()>0
orderby m.MethodsCallingMe.Count() descending
select new { m,NbCallingMethods= m.MethodsCallingMe }).Take(100)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Popular Classes violating CppCheck rules</Name>
from t in Types where t.Issues.Where(i=>i.ToolName=="CppCheck").Count()>0
orderby t.TypesUsingMe.Count() descending
select new { t,ClassesUsingMe= t.TypesUsingMe}]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>CppCheck Violation Famillies with Most violations </Name>
let groups = Application.Issues.Where(i=>i.ToolName=="CppCheck").GroupBy(t => t.IssueFamilly)

from g in groups
orderby g.Count() descending
select new { issue=g.FirstOrDefault(),count=g.Count() }]]></Query>
      </Group>
      <Group Name="CPD Queries" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>All CPD duplications</Name>
from issue in Issues  where issue.ToolName=="CPD"
select new { issue,issue.FilePath,issue.BeginLine }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most duplicated code lines</Name>
from issue in Issues  where issue.ToolName=="CPD"
orderby issue.NbDuplicationCopies descending
select new { issue,issue.NbDuplicationCopies }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Big duplications</Name>
from issue in Issues  where issue.ToolName=="CPD"
orderby issue.NbLinesCopied descending
select new { issue,issue.NbLinesCopied }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Classes containing big duplication</Name>
(from t in Types where t.Issues.Where(i=>i.ToolName=="CPD" && i.NbLinesCopied>100).Count()>0
orderby t.Issues.Count() descending
select new { t }).Take(100)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Classes containing Many duplications</Name>
(from t in Types where t.Issues.Where(i=>i.ToolName=="CPD" && i.NbDuplicationCopies>10).Count()>0
orderby t.Issues.Count() descending
select new { t }).Take(100)]]></Query>
      </Group>
    </Group>
    <Group Name="Statistics" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used types (Rank)</Name>
(from t in Application.Types orderby t.Rank descending
 select new { t, t.Rank }).Take(50)

// TypeRank values are computed by applying 
// the Google PageRank  algorithm on the 
// graph of types' dependencies. Types with 
// high Rank are the most used ones.
// See the definition of the TypeRank metric here: 
// http://www.cppdepend.com/Metrics.aspx#TypeRank]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (Rank)</Name>
(from m in Application.Methods orderby m.Rank descending
 select new { m, m.Rank }).Take(50)

// MethodRank values are computed by applying 
// the Google PageRank  algorithm on the graph of 
// methods' dependencies. Methods with high Rank 
// are the most used ones. See the definition of 
// the MethodRank metric here:
// http://www.cppdepend.com/Metrics.aspx#MethodRank]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used namespaces (#NamespacesUsingMe )</Name>
(from n in Namespaces orderby n.NbNamespacesUsingMe descending
 select new { n, n.NamespacesUsingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used types (#TypesUsingMe )</Name>
(from t in Types orderby t.NbTypesUsingMe descending
 select new { t, t.TypesUsingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (#MethodsCallingMe )</Name>
(from m in Methods orderby m.NbMethodsCallingMe descending
 select new { m, m.MethodsCallingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces that use many other namespaces (#NamespacesUsed )</Name>
(from n in Application.Namespaces orderby n.NbNamespacesUsed descending
 select new { n, n.NamespacesUsed }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that use many other types (#TypesUsed )</Name>
(from t in Application.Types orderby t.NbTypesUsed descending
 select new { t, t.TypesUsed }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods that use many other methods (#MethodsCalled )</Name>
(from m in Application.Methods orderby m.NbMethodsCalled descending
 select new { m, m.MethodsCalled }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level Projects (Level)</Name>
from a in Application.Projects orderby a.Level descending
select new { a, a.Level }

// Classify Projects by their Level values.
// See the definition of the projectLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level namespaces (Level)</Name>
from n in Application.Namespaces orderby n.Level descending
select new { n, n.Level }

// Classify namespaces by their Level values.
// See the definition of the NamespaceLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level types (Level)</Name>
from t in Application.Types orderby t.Level descending
select new { t, t.Level }

// Classify types by their Level values.
// See the definition of the TypeLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level methods (Level)</Name>
from m in Application.Methods orderby m.Level descending
select new { m, m.Level }

// Classify methods by their Level values.
// See the definition of the MethodLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
    </Group>
    <Group Name="Samples of Custom rules" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the project P1 is not using the project P2</Name>
warnif count > 0 from a in Application.Projects where 
  a.IsUsing ("P2".AllowNoMatch().MatchProject()) &&
  (a.Name == @"P1")
select a
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the project P1 is only using the Projects P2 or P3</Name>
warnif count > 0 from a in Application.Projects where 
  ( !a.IsUsing ("P2".AllowNoMatch().MatchProject()) ||
    !a.IsUsing ("P3".AllowNoMatch().MatchProject()) ||
    a.ProjectsUsed.Count() != 2) // Must not be used more than 2 Projects 
&& 
  (a.Name == @"P1")
select new { a, a.ProjectsUsed }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that only 3 Projects are using Project P</Name>
warnif count != 3 from a in Application.Projects where 
  a.IsUsing ("P".AllowNoMatch().MatchProject())
select a
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all methods that call Foo.Fct1() also call Foo.Fct2(Int32)</Name>
warnif count > 0 from m in Application.Methods where 
   m.IsUsing ("Foo.Fct1()".AllowNoMatch()) &&
  !m.IsUsing ("Foo.Fct2(Int32)".AllowNoMatch())
select m
]]></Query>
      <Group Name="Custom Naming Conventions" Active="False" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all types that derive from Foo, has a name that ends up with Foo</Name>
warnif count > 0 from t in Application.Types where 
   t.DeriveFrom ("Foo".AllowNoMatch().MatchType()) &&
  !t.NameLike (@"Foo$")
select new { t, t.NbLinesOfCode }
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all namespaces begins with CompanyName.ProductName</Name>
warnif count > 0 from n in Application.Namespaces where 
  !n.NameLike (@"^CompanyName.ProductName")
select new { n, n.NbLinesOfCode } ]]></Query>
      </Group>
    </Group>
    <Group Name="Trend Metrics" Active="True" ShownInReport="False">
      <Group Name="Code Size" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code" Unit="LoC" />  
Application.Projects.Sum(a => a.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code (JustMyCode)" Unit="LoC" />
JustMyCode.Methods.Sum(m => m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code (NotMyCode)" Unit="LoC" />
Application.Methods.Where(m => !JustMyCode.Contains(m))
                   .Sum(m => m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Added since the Baseline" Unit="LoC" />  
( from a in Application.Projects
  let nbLocAdded = a.IsPresentInBothBuilds() ? 
                   a.NbLinesOfCode - (int)a.OlderVersion().NbLinesOfCode :
                   a.NbLinesOfCode
  select nbLocAdded)
.Sum(loc => loc)

// A value is computed by this Trend Metric query
// only if a Baseline for Comparison is provided.
// See Project Properties > Analysis > Baseline for Comparison
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Source Files" Unit="Source Files" />
Application.Projects.SelectMany(
  a => a.SourceDecls.Select(sd => sd.SourceFile.FilePathString.ToLower()))
.Distinct()
.Count()

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Comments" Unit="Lines" />  
Application.Projects.Sum(a => a.NbLinesOfComment)

// So far comments are only extracted from C# source code.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Projects" Unit="Projects" />
Application.Projects.Count()

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Namespaces" Unit="Namespaces" />
Application.Namespaces.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Types" Unit="Types" />
Application.Types.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Classes" Unit="Types" />
Application.Types.Count(t => t.IsClass && !t.IsGeneratedByCompiler)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Abstract Classes" Unit="Types" />
Application.Types.Count(t => t.IsClass && t.IsAbstract)

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Interfaces" Unit="Types" />
Application.Types.Count(t => t.IsInterface)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Structures" Unit="Types" />
Application.Types.Count(t => t.IsStructure)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Methods" Unit="Methods" />
Application.Methods.Count(m => !m.IsGeneratedByCompiler)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Abstract Methods" Unit="Methods" />
Application.Methods.Count(m => m.IsAbstract)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Concrete Methods" Unit="Methods" />
Application.Methods.Count(m => !m.IsAbstract && !m.IsGeneratedByCompiler)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Fields" Unit="Fields" />
Application.Fields.Count(f => 
   !f.IsEnumValue && 
   !f.IsGeneratedByCompiler && 
   !f.ParentType.IsEnumeration)

]]></Query>
      </Group>
      <Group Name="Maximum and Average" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # Lines of Code for Methods (JustMyCode)" Unit="LoC" />
JustMyCode.Methods
          .Max(m => m.NbLinesOfCode)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) method with largest # Lines of Code
// JustMyCode.Methods.OrderByDescending(m => m.NbLinesOfCode).Take(1).Select(m => new {m, m.NbLinesOfCode})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Methods" Unit="LoC" />
Application.Methods.Where(m => m.NbLinesOfCode > 0)
                   .Average(m => m.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Methods with at least 3 Lines of Code" Unit="LoC" />
Application.Methods.Where(m => m.NbLinesOfCode >= 3)
                   .Average(m => m.NbLinesOfCode)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # Lines of Code for Types (JustMyCode)" Unit="LoC" />
JustMyCode.Types
          .Max(t => t.NbLinesOfCode)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) type with largest # Lines of Code
// JustMyCode.Types.OrderByDescending(t => t.NbLinesOfCode).Take(1).Select(t => new {t, t.NbLinesOfCode})

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Types" Unit="LoC" />
Application.Types.Where(t => t.NbLinesOfCode > 0)
                 .Average(t => t.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods
          .Max(m => m.CyclomaticComplexity)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the most complex method, according to Cyclomatic Complexity
// Application.Methods.OrderByDescending(m => m.CyclomaticComplexity).Take(1).Select(m => new {m, m.CyclomaticComplexity})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Cyclomatic Complexity for Types" Unit="Paths" />
Application.Types
          .Max(t => t.CyclomaticComplexity)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the most complex method, according to Cyclomatic Complexity
// Application.Methods.OrderByDescending(m => m.CyclomaticComplexity).Take(1).Select(m => new {m, m.CyclomaticComplexity})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods.Where(m => m.NbLinesOfCode> 0)
                   .Average(m => m.CyclomaticComplexity)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Cyclomatic Complexity for Types" Unit="Paths" />
Application.Types.Where(t => t.NbLinesOfCode> 0)
                   .Average(t => t.CyclomaticComplexity)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Nesting Depth for Methods" Unit="Scopes" />
Application.Methods
          .Max(m => m.NestingDepth)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the method with highest NestingDepth.
// Application.Methods.OrderByDescending(m => m.NestingDepth).Take(1).Select(m => new {m, m.NestingDepth})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Nesting Depth for Methods" Unit="Scopes" />
Application.Methods.Average(m => m.NestingDepth)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # of Methods for Types" Unit="Methods" />
Application.Types
           .Max(t => t.NbMethods) 
           .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) type with largest # of Methods
// JustMyCode.Types.OrderByDescending(t => t.NbMethods).Take(1).Select(t => new {t, t.Methods})

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Methods for Types" Unit="Methods" />
Application.Types.Average(t => t.NbMethods)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # of Methods for Interfaces" Unit="Methods" />
Application.Types.Where(t => t.IsInterface)
           .Max(t => t.NbMethods) 
           .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) type with largest # of Methods
// JustMyCode.Types.OrderByDescending(t => t.NbMethods).Take(1).Select(t => new {t, t.Methods})]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Methods for Interfaces" Unit="Methods" />
JustMyCode.Types.Where(t => t.IsInterface)
                .Average(t => t.NbMethods)
]]></Query>
      </Group>
      <Group Name="Third-Party Usage" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Projects Used" Unit="Projects" />
ThirdParty.Projects.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Namespaces Used" Unit="Namespaces" />
ThirdParty.Namespaces.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Types Used" Unit="Types" />
ThirdParty.Types.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Methods Used" Unit="Methods" />
ThirdParty.Methods.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Fields Used" Unit="Fields" />
ThirdParty.Fields.Count()]]></Query>
      </Group>
    </Group>
    <Group Name="Defining JustMyCode" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Discard methods in a directory  from JustMyCode</Name>
notmycode from m in Methods.Where(a=>a.SourceDecls.FirstOrDefault()!=null && a.SourceDecls.FirstOrDefault().SourceFile.DirectoryPath.Contains("path to exclude"))
select m

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Discard types in a directory  from JustMyCode</Name>
notmycode from t in Types.Where(a=>a.SourceDecls.FirstOrDefault()!=null && a.SourceDecls.FirstOrDefault().SourceFile.DirectoryPath.Contains("path to exclude"))
select t

]]></Query>
    </Group>
  </Queries></NDepend>